<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>RowMaster Pro</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; -webkit-user-select: none; }
        body { background: #0b0b0b; color: #fff; height: 100dvh; width: 100vw; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; cursor: crosshair; }

        .side-bar { 
            position: absolute; right: 10px; top: 10px; bottom: 10px; 
            display: flex; flex-direction: column; gap: 8px; z-index: 100; 
            justify-content: center; width: 50px; transition: opacity 0.3s;
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .side-bar, .ui-panel { opacity: 0; pointer-events: none; }
        }

        .btn { 
            width: 44px; height: 44px; border-radius: 12px; 
            border: 1px solid rgba(255,255,255,0.1); 
            background: rgba(40, 40, 40, 0.9); color: #fff; 
            font-size: 20px; display: flex; align-items: center; 
            justify-content: center; backdrop-filter: blur(5px); flex-shrink: 0; 
        }
        .btn.active { background: #9333ea; border-color: #a855f7; }
        
        .ui-panel { 
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); 
            background: rgba(20,20,20,0.95); padding: 15px; border-radius: 20px; 
            display: flex; flex-direction: column; gap: 12px; width: 85%; max-width: 320px; 
            border: 1px solid rgba(255,255,255,0.1); z-index: 110; transition: 0.3s; 
        }
        .ui-panel.hidden { opacity: 0; transform: translateX(-50%) translateY(100px); pointer-events: none; }

        .row { display: flex; align-items: center; gap: 10px; font-size: 10px; color: #aaa; text-transform: uppercase; }
        input[type="range"] { flex: 1; accent-color: #9333ea; }
        .colors { display: flex; justify-content: center; gap: 12px; }
        .color-dot { width: 28px; height: 28px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; }
        .color-dot.active { border-color: #fff; transform: scale(1.1); }

        #kofi-modal {
            position: fixed; inset: 0; background: rgba(0,0,0,0.8);
            display: none; align-items: center; justify-content: center; z-index: 200;
        }
        .kofi-content {
            background: #1a1a1a; padding: 25px; border-radius: 24px; text-align: center;
            border: 1px solid #333; max-width: 280px;
        }
        .kofi-btn {
            background: #ff5f5f; color: white; border: none; padding: 12px 24px;
            border-radius: 50px; margin-top: 15px; font-weight: bold; cursor: pointer; font-size: 16px;
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>

<div class="side-bar" id="sidebar">
    <button id="bT" class="btn" onclick="app.setMode('text')">T</button>
    <button class="btn" onclick="app.saveAsFile()">üíæ</button>
    <div style="height:2px"></div>
    <button id="bL" class="btn active" onclick="app.setMode('line')">‚ûñ</button>
    <button id="bD" class="btn" onclick="app.setMode('draw')">‚úçÔ∏è</button>
    <button class="btn" onclick="app.toggleUI()">üëÅÔ∏è</button>
    <button class="btn" onclick="app.clear()">üóëÔ∏è</button>
    <div style="height:2px"></div>
    <button class="btn" onclick="app.rotate()">üîÑ</button>
    <button class="btn" onclick="document.getElementById('fi').click()">üì∑</button>
    <button class="btn" onclick="app.showKofi()">‚öôÔ∏è</button>
</div>

<div class="ui-panel" id="ui">
    <div class="row">Size <input type="range" id="sizeInp" min="1" max="60" value="8" oninput="app.updateSize(this.value)"></div>
    <div class="row">Alpha <input type="range" id="alphaInp" min="0.1" max="1" step="0.1" value="0.7" oninput="app.st.alpha=this.value"></div>
    <div class="colors">
        <div class="color-dot active" style="background:#9333ea" onclick="app.setColor('#9333ea', this)"></div>
        <div class="color-dot" style="background:#ef4444" onclick="app.setColor('#ef4444', this)"></div>
        <div class="color-dot" style="background:#22c55e" onclick="app.setColor('#22c55e', this)"></div>
        <div class="color-dot" style="background:#3b82f6" onclick="app.setColor('#3b82f6', this)"></div>
        <div class="color-dot" style="background:#facc15" onclick="app.setColor('#facc15', this)"></div>
    </div>
</div>

<div id="kofi-modal" onclick="this.style.display='none'">
    <div class="kofi-content" onclick="event.stopPropagation()">
        <h3 style="margin-bottom:10px">Support Project</h3>
        <p style="font-size:14px; color:#aaa">If you like RowMaster, you can buy me a coffee!</p>
        <button class="kofi-btn" onclick="window.open('https://ko-fi.com/shawlserenade', '_blank')">‚ù§Ô∏è Ko-fi</button>
    </div>
</div>

<input type="file" id="fi" accept="image/*" style="display:none" onchange="app.hFile(this)">

<script id="app-state-loader">
    window.PRELOADED_STATE = null; 
    window.PRELOADED_IMAGE = null; 
</script>

<script>
const app = {
    cvs: document.getElementById('canvas'),
    ctx: document.getElementById('canvas').getContext('2d'),
    img: null, fname: '', rawImgData: null,
    st: { x:0, y:0, sc:1, rot:0, ly:0, mode:'line', th:8, alpha:0.7, col:'#9333ea', paths: [], notes: [] },
    pointers: new Map(), drag: null, lastD: 0,

    init() {
        this.resize();
        window.onresize = () => this.resize();
        window.addEventListener('keydown', e => this.onKey(e));
        this.cvs.addEventListener('pointerdown', e => this.onDown(e));
        window.addEventListener('pointermove', e => this.onMove(e));
        window.addEventListener('pointerup', () => { this.pointers.clear(); this.drag = null; this.save(); });
        this.cvs.addEventListener('wheel', e => { e.preventDefault(); this.doZoom(e.deltaY < 0 ? 1.1 : 0.9, e.clientX, e.clientY); }, {passive: false});
        
        if (window.PRELOADED_STATE && window.PRELOADED_IMAGE) {
            this.st = window.PRELOADED_STATE;
            this.rawImgData = window.PRELOADED_IMAGE;
            const i = new Image();
            i.onload = () => {
                this.img = i;
                document.getElementById('sizeInp').value = this.st.th;
                document.getElementById('alphaInp').value = this.st.alpha;
            };
            i.src = this.rawImgData;
        }
        this.loop();
    },

    resize() { this.cvs.width = window.innerWidth; this.cvs.height = window.innerHeight; },
    onKey(e) { if (e.key === 'ArrowUp') this.st.ly -= 10; if (e.key === 'ArrowDown') this.st.ly += 10; this.save(); },

    hideKeyboard() {
        if (document.activeElement && document.activeElement.tagName !== 'BODY') {
            document.activeElement.blur();
        }
        const selection = window.getSelection();
        if (selection) selection.removeAllRanges();
    },

    toLocal(ex, ey) {
        const dx = ex - this.st.x, dy = ey - this.st.y;
        const ang = -this.st.rot * Math.PI / 180;
        const cos = Math.cos(ang), sin = Math.sin(ang);
        return { x: (dx * cos - dy * sin) / this.st.sc, y: (dx * sin + dy * cos) / this.st.sc };
    },

    onDown(e) {
        this.pointers.set(e.pointerId, e);
        const p = this.toLocal(e.clientX, e.clientY);
        
        this.hideKeyboard();

        if (this.st.mode === 'text') {
            setTimeout(() => {
                const txt = prompt("–ó–∞–º–µ—Ç–∫–∞:");
                if (txt) {
                    this.st.notes.push({ x: p.x, y: p.y, t: txt, c: this.st.col });
                    this.save();
                }
                this.setMode('line');
                this.hideKeyboard();
            }, 50);
        } else if (this.st.mode === 'draw') {
            this.drag = 'drawing';
            this.st.paths.push({ x: p.x, y: p.y, s: true, col: this.st.col, th: this.st.th / this.st.sc, alpha: this.st.alpha });
        } else if (this.pointers.size === 1) {
            const lineY = this.st.y + this.st.ly;
            this.drag = Math.abs(e.clientY - lineY) < 35 ? 'line' : 'img';
        } else {
            this.drag = 'zoom';
            const pts = [...this.pointers.values()];
            this.lastD = Math.hypot(pts[0].clientX - pts[1].clientX, pts[0].clientY - pts[1].clientY);
        }
    },

    onMove(e) {
        if (!this.pointers.has(e.pointerId)) return;
        const prev = this.pointers.get(e.pointerId);
        this.pointers.set(e.pointerId, e);
        if (this.drag === 'drawing') {
            const p = this.toLocal(e.clientX, e.clientY);
            this.st.paths.push({ x: p.x, y: p.y });
        } else if (this.drag === 'img') {
            this.st.x += e.clientX - prev.clientX;
            this.st.y += e.clientY - prev.clientY;
        } else if (this.drag === 'line') {
            this.st.ly += e.clientY - prev.clientY;
        } else if (this.drag === 'zoom' && this.pointers.size === 2) {
            const pts = [...this.pointers.values()];
            const d = Math.hypot(pts[0].clientX - pts[1].clientX, pts[0].clientY - pts[1].clientY);
            this.doZoom(d / this.lastD, (pts[0].clientX + pts[1].clientX) / 2, (pts[0].clientY + pts[1].clientY) / 2);
            this.lastD = d;
        }
    },

    doZoom(f, cx, cy) {
        const oldS = this.st.sc;
        this.st.sc = Math.max(0.1, Math.min(20, this.st.sc * f));
        const ratio = this.st.sc / oldS;
        this.st.x = cx - (cx - this.st.x) * ratio;
        this.st.y = cy - (cy - this.st.y) * ratio;
        this.save();
    },

    render() {
        const { ctx, cvs, st, img } = this;
        ctx.fillStyle = "#0b0b0b"; ctx.fillRect(0,0,cvs.width,cvs.height);
        if (!img) return;
        ctx.save();
        ctx.translate(st.x, st.y);
        ctx.rotate(st.rot * Math.PI / 180);
        ctx.drawImage(img, -img.width*st.sc/2, -img.height*st.sc/2, img.width*st.sc, img.height*st.sc);
        ctx.lineJoin = 'round'; ctx.lineCap = 'round';
        st.paths.forEach((p, i) => {
            if (p.s) { ctx.beginPath(); ctx.strokeStyle = p.col; ctx.globalAlpha = p.alpha || 0.7; ctx.lineWidth = p.th * st.sc; ctx.moveTo(p.x * st.sc, p.y * st.sc); }
            else { ctx.lineTo(p.x * st.sc, p.y * st.sc); if (!st.paths[i+1] || st.paths[i+1].s) { ctx.stroke(); } }
        });
        ctx.globalAlpha = 1;
        ctx.font = "bold 18px sans-serif";
        st.notes.forEach(n => { ctx.fillStyle = n.c; ctx.fillText(n.t, n.x * st.sc, n.y * st.sc); });
        ctx.restore();
        if (st.mode === 'line') {
            ctx.strokeStyle = st.col; ctx.lineWidth = st.th; ctx.globalAlpha = st.alpha;
            ctx.beginPath(); ctx.moveTo(0, st.y + st.ly); ctx.lineTo(cvs.width, st.y + st.ly); ctx.stroke();
            ctx.globalAlpha = 1;
        }
    },

    loop() { this.render(); requestAnimationFrame(() => this.loop()); },
    save() { if (this.fname && this.fname !== "Saved_Project") localStorage.setItem('prj_' + this.fname, JSON.stringify(this.st)); },
    toggleUI() { document.getElementById('ui').classList.toggle('hidden'); },
    showKofi() { document.getElementById('kofi-modal').style.display = 'flex'; },
    setMode(m) { this.st.mode = m; document.getElementById('bL').className = 'btn'+(m==='line'?' active':''); document.getElementById('bD').className = 'btn'+(m==='draw'?' active':''); document.getElementById('bT').className = 'btn'+(m==='text'?' active':''); },
    updateSize(v) { this.st.th = v; this.save(); },
    setColor(c, el) { this.st.col = c; document.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active')); el.classList.add('active'); this.save(); },
    rotate() { this.st.rot = (this.st.rot + 90) % 360; this.save(); },
    
    clear() { 
        const choice = prompt("–ß—Ç–æ –æ—á–∏—Å—Ç–∏—Ç—å?\n1 - –í—Å—ë\n2 - –¢–æ–ª—å–∫–æ —Ä–∏—Å—É–Ω–∫–∏\n3 - –¢–æ–ª—å–∫–æ –∑–∞–º–µ—Ç–∫–∏\n(–í–≤–µ–¥–∏—Ç–µ —Ü–∏—Ñ—Ä—É –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –û—Ç–º–µ–Ω–∞)");
        if (choice === "1") {
            this.st.paths = [];
            this.st.notes = [];
        } else if (choice === "2") {
            this.st.paths = [];
        } else if (choice === "3") {
            this.st.notes = [];
        }
        if (choice) this.save();
    },
    
    saveAsFile() {
        if (!this.rawImgData) { alert("–°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∫–∞—Ä—Ç–∏–Ω–∫—É!"); return; }
        const name = prompt("–ù–∞–∑–≤–∞–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è:");
        if (!name) return;
        let docClone = document.documentElement.cloneNode(true);
        let loaderScript = docClone.querySelector('#app-state-loader');
        loaderScript.textContent = `window.PRELOADED_STATE = ${JSON.stringify(this.st)}; window.PRELOADED_IMAGE = "${this.rawImgData}";`;
        const blob = new Blob([docClone.outerHTML], {type: 'text/html'});
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
        a.download = name + ".html"; a.click();
    },

    hFile(input) {
        const f = input.files[0]; if (!f) return;
        this.fname = f.name;
        const r = new FileReader();
        r.onload = e => {
            this.rawImgData = e.target.result;
            const i = new Image();
            i.onload = () => {
                this.img = i;
                const sv = localStorage.getItem('prj_' + this.fname);
                if (sv) Object.assign(this.st, JSON.parse(sv));
                else { this.st.sc = Math.min(this.cvs.width/i.width, this.cvs.height/i.height)*0.8; this.st.x = this.cvs.width/2; this.st.y = this.cvs.height/2; this.st.ly = 0; }
                document.getElementById('sizeInp').value = this.st.th;
                document.getElementById('alphaInp').value = this.st.alpha;
            };
            i.src = this.rawImgData;
        };
        r.readAsDataURL(f);
    }
};
app.init();
</script>
</body>
</html>
